angular: 

it is a frontend javascript framework for building interactive, modern web user interfaces
it's also a collection of tools and feature like CLI (eg. ng serve, ng serve --open, etc), Debugging tools, IDE plugin\

why use angular instead of using "just javascript"?

for trivial websites and web apps, you would not need angular.But frameworks like Angular do really shine
as your applications become more complex because they simplify the process of building complex, highly interactive web user interfaces.

reason: 
1. you can write declarative code with angular instead of imperative code ( step by step instructions) like Vanilla javascript

components in angular:
you build a component tree. 
one angular application = one component tree

eg:                         app component
								|	|					|
				Header Component     User component 	Tasks component			

components are custom HTML elements

Why components?

1. Modular Applications:
break up complex apps into simple building blocks
split up responsibilities and concerns
build a component once and reuse it often as needed.

2. Better Dev Process
Assign diff team members to diff components
Share components and logic across the team
reduce dependencies


Angular has some OOP concepts & principles

Angular uses TypeScript (not vanilla javascript)

Typescript is a Javascript superset - an extension of JavaScript. It extends JS syntax to support strong and strict typing. Unlike vanilla js, TS enforces types and prevents unexpected value type changes

Easier dev with typescript: 
with TS, you can often catch errors early on during development. 
without TS, those errors would be undetected and then posibly only surface at runtime when application crashes or behaves incorrectly.


Angular team releases -> major releases every 6 months
despite labeled as major releases, these releases do not break your code & " change the framework"

2016 - angular 2 released

2017 - angular 4 released (v3 skipped)

2017 - version 5 releaes

-: - angular 6 - 13 released 

2022 - angular 14 and 15 released: angular 14 introduces "standalone components"

2023 - angular 16 is released. : angular 16 introduces signals

But to follow along with exactly the same setup as shown over the next lectures, you should create new projects via ng new first-angular-app --no-zoneless.

In the next lecture, I just run ng new first-angular-app - but with Angular v21+, this will give you a project that is configured in a "zoneless" mode, a mode we'll explore in detail a little later in the course. Therefore, to get started, I recommend creating projects with the --no-zoneless flag.

latest as per 2026: v21 is the stable version latest


create new angular app: ng new first-angular-app --no-zoneless
start the app: npm start


folder structure:

all the files you find in the top level of your project are configuration files

package files: manage the dependencies of your application.
we will use features from these dependencies in our code

angular.json: contains extra configuration for angular CLI and angular provided tools in general. You dont need to change anything in this files

.editorconfig: contains some rules for the code editorconfig
.gitignore: relevant if you are using gitignore

src folder -> 
app folder: here you will build angular components
naming convention standard: app.component.html, css, ts. 

styles.css file: global styles across all components
index.html: main html file which will be loaded when visitors visit your websites

main.ts : it will be the first code file, to be executed when the angular application loads in the browser of the visitors, i.e. the code of this will be executed first

assets folder: store images to be used

app folder: in this folder you will build and combine all the angular components


npm install: install all those dependencies mentioned in the package.json
need to do it only once


## npm start: under the hood it executes "npm serve"


### HOW IS THE SCREEN LOADED?, I MEAN HOW DOES CONTENT END UP ON OUR SCREEN?

1. the index.html is the file that loads.
2. in this file, you can see in the <body> element, there is this custom <app-root> element, but there is no <script> tag in this file.
3. But when you run the application and do the "page source" on browser, you see some <script> tag with js file imports as below:
	<script src="polyfills.js" type="module"></script><script src="main.js" type="module"></script></body>
4. those are injected into this file automatically by the Angular CLI when you build and run your application
5. That is how the code in this main.ts gets executed after begin compiled into JavaScript code, which is also done by the Angular CLI. That's why in the page source, we find this "main.js" file being imported
6. so its the compiled code of main.ts that gets executed.
7. this code executes the bootstrapApplication() method provided by an angular package, and this method takes an Angular component as input.
	eg: bootstrapApplication(AppComponent).
	AppComponent -> import from ./app/app.component. => now here the .ts is missing from app.component.ts, reason: for importing something from .ts file, we should omit '.ts' extension in the import
8. AppComponent is a class inside the app.component.ts, and it has a decorator @Component(...) attached to it. This decorator adds some metadata to the thing it is attached to (in this case, the AppComponent class)
9. we are importing this decorator from the "core" package of the "angular" framework: import {Component} from '@angular/core';
10. It is this decorator that converts a standard class into such a Angular Component that is treated as a component i.e. a custom HTML element
11. This @Component decorator receives some object having some metadata:
				@Component({
				selector: 'app-root',
				standalone: true,
				imports: [],
				templateUrl: './app.component.html',
				styleUrl: './app.component.css',
				})
				as you can see, @Component takes the object: 
					{
						selector: 'app-root',
						standalone: true,
						imports: [],
						templateUrl: './app.component.html',
						styleUrl: './app.component.css',
					}

12. "selector" property: it tells Angular for which elements to look in the HTML code, so that those elements can be replaced by the component and its markup.
13. The markup of this component is stored in the file whose path is given by this "templateUrl" property
14. "styleUrl": this contains the styles that apply only to the markup of this component. They can't clash with other styles
15. "standalone": true: this property is by default true for Angular versions >= 19. If version is lesser, you need to define it explicitly.
	it means that the component does NOT belong to any NgModule and it manages its own dependencies

After Angular 20: the file naming pattern has changed. Eg. its now only header.ts instead of header.component.ts


@Component({
    selector: 'app-header',
    // template: '<h1>Hello World </h1>' - you can use this for small UI / demos. For more complex ones, use templateUrl: html page
	....
})

 templateUrl: './header.component.html': this "./" means that this file is present in the same folder

 ## standalone: true - it means it is a standalone component and not module based component

 # module based component:
	1. Components are declared inside @NgModule
	2. Modules manage:
		Declarations
		Imports (CommonModule, FormsModule, etc.)
		Exports
	3.AppModule (root module) bootstraps the app

# standalone component:
	1. No module needed
	2. Component manages its own dependencies
	3.Can be:
		Bootstrapped directly
		Lazy loaded
		Used inside other standalone components or modules

# Only if you add this <app-header> inside index.html, it wont work as angular looks for components to run in main.ts
so, in main.ts add like: bootstrapApplication(HeaderComponent); - now angular its aware of it, it finds its tag and renders it

but this is not how you build angular app. The idea is build nested components, app Component will be the root component, others will be inside it. eg:
							        app component
							|	          |				|
				Header Component	User Component    Tasks Component 
														    |
														Task Component	
	
One Angular Appliction = One Component Tree

so the idea is that you call the bootstrapApplication(..) only once, on the root component, and then you use other components inside that root component's template
eg: replace the <header> in the app.component.html with our customer <app-header> tag

Error: app-header is not a known element: it means you have not imported our HeaderComponent inside the app.component.ts's @Component decorator

## styles.css in top level of project: applies styles to all the components
## css files of components: apply only to that particular components

## When using the assets folder to import images, etc, you should make sure that the angular.json file in your root directory has an 
entry as 
"assets": [
	"src/assets"
]
If not, manually add "src/assets" inside the "assets"[] array, also add "src/favicon.ico" to see this as well



### üß© Pro tip for your Angular learning repo

Your structure should look like this:

angular-tutorial/
 ‚îú‚îÄ‚îÄ first-angular-app/
 ‚îú‚îÄ‚îÄ 01-starting-project/
 ‚îú‚îÄ‚îÄ angular-notes.txt
 ‚îî‚îÄ‚îÄ .git

 ## I had .git file in first-angular-app as well. But there should be only one .git file and that at the root.
 delete the .git file inside any other directory.


 ## Creating Custom Component using Angular CLI:

 ng generate component <<name>> <<path>>
		OR 
 ng g c <<name>> <<path>>

 Eg: ng generate component user: -> angular CLI creates the user folder inside the src/app folder

 extra file added: user.component.specs.ts -> used for automated tests, not needed right now

 ## If you have components that dont have anything between them: like <app-user></app-user>
 then you can write them as <app-user/>
 NOTE: Only void and foreign components can be self-closed as above

 ## 
 export class UserComponent {
  selectedUser = ...
} 

Angular will make this "selectedUser" property and its value available to its markup i.e. user.component.html
so, all the properties you are defining inside the class, are available to the template of that component

### Just make sure you do not add "let" or "const" keyword to the property
Reason: Because:
let / const are for block-scoped variables
Class fields are properties, not local variables

### STRING INTERPOLATION:

{{....}} -> by adding these two curly braces in the html template, you can now use any of your public property from your component class

eg. <span> {{ selectedUser.name }} </span>

## We use this string interpolation only when needed between the tags as above

## Property Binding Syntax:
Property binding is how you bind a value from the component class to a property of a DOM element or Angular component.

eg: <img [src]="'assets/users/' + selectedUser.avatar" alt="">
You wrap the name of the property that is to be set inside square brackets: (property src in above example)

here I am constructing a string which is the path of the image.
NOTE: " 'assets/users/' + selectedUser.avatar".
here we have used single quotes inside the main string


## Dynamic Data Output: Create a randomIndex which is a random index generated and use it to access any of the DUMMY_USERS array object which is a user.

### Getters:
eg: 
// adding a getter
  get imagePath(){
    return 'assets/users/' + this.selectedUser.avatar; // adding "this" here as we want to access the property of the class from within that same class
  }
inside UserComponent class

and add it in user.component.html like this: <img [src]="imagePath">


### Listening to Events with Event Binding

We often need to listen to user input, so that you can update the UI upon certain kinds of input
Steps: 
1. Listen to User input
2. Change the UI on the basis of User input

Eg: we would like to add a listener to that button to listen for click events

In Angular where you write declarative code, you add event listeners to elements by going to those elements in your templates

Angular's syntax for adding an event listener to an element:
	<button (click)="onSelectUser()">

here as you can see the "click" event is added, which is wrapped in curly braces

and this onSelectUser() is added inside the Component class, let's say the UserComponent in this case.
and you then add it to the template as shown above, with curly braces "()" as if you are calling this method

### MANAGING STATES AND CHANGING Data

Eg: When we click the box, instead of getting "Clicked!" in the console, we now want to update the UI
i.e for example, the user should be changed everytime I click it
We need to manage some data in our component class, which when changed has an impact on the UI. 
This kind of data is called as "state", because it is data that will have impact on the state of the UI

#### Angular's Change Detection Mechanism

1Ô∏è‚É£ What is Change Detection in Angular?

Change Detection is Angular‚Äôs way of keeping the view (HTML) in sync with the model (component data).

üëâ Whenever something changes in your component:

this.name = 'Aditya';

Angular automatically updates:

<p>{{ name }}</p>

That automatic update is change detection.

## 2Ô∏è‚É£ The Big Question: How does Angular know something changed?

JavaScript itself does NOT notify when variables change.

Angular needs a signal like:

‚ÄúA button was clicked‚Äù

‚ÄúAn HTTP response arrived‚Äù

‚ÄúA timer finished‚Äù

‚ÄúA promise resolved‚Äù

That signal is provided by Zone.js ‚úÖ

3Ô∏è‚É£ What is Zone.js (in simple words)?

Zone.js is a library that patches async APIs in JavaScript.

It monitors async operations like:

setTimeout

setInterval

Promise.then

addEventListener

HTTP requests

async / await

So Angular knows:

‚ÄúHey! Something async just finished ‚Üí UI might need updating.‚Äù

4Ô∏è‚É£ How Angular + Zone.js Work Together (Step-by-Step)
üîÅ Example: Button Click
<button (click)="increment()">+</button>
<p>{{ count }}</p>

increment() {
  this.count++;
}

üîÑ What actually happens internally

1Ô∏è‚É£ User clicks the button
2Ô∏è‚É£ Browser triggers a click event (async task)
3Ô∏è‚É£ Zone.js intercepts this event
4Ô∏è‚É£ Zone.js informs Angular:

‚ÄúAn async task just completed‚Äù
5Ô∏è‚É£ Angular runs change detection
6Ô∏è‚É£ Angular checks:

Did count change? ‚úÖ
7Ô∏è‚É£ Angular updates the DOM

‚ú® You didn‚Äôt call anything manually ‚Äî it just worked.

### 5Ô∏è‚É£ Change Detection Cycle (Core Flow)

Whenever Zone.js finishes an async task, Angular does:

Zone.js ‚Üí Angular ‚Üí ApplicationRef.tick()


Which means:

Angular checks all components
Compares old values vs new values
Updates DOM where needed
This is called a change detection cycle

6Ô∏è‚É£ What Exactly Does Angular Check?

Angular checks template expressions, like:

{{ name }}
{{ count }}
[user]="selectedUser"

It compares:
previous value  vs  current value
If different ‚Üí DOM update


### Introduction to signals

There are two approaches for updating state

Option 1:
1.Relying on Zone.js & Angular's change detection Mechanism
It works automatically, no special instructions required. Supported since Angular 2

2. Signals: 
Use signals to notify Angular about value changes and required UI updates
Requires usage of special "signal" instructions and code. Supported since Angular 16

Signals are special kinds of values that tell Angular when they change
 ### Signal is an object that stores a value(any type of value, including nested objects)

 eg. create a signal like this:
 selectedUser = signal(DUMMY_USERS[randomIndex]); -> inside user.component.ts
 -- signal is more like a container, that contains a value like this dummy user here.
 and when you change that value, Angular will be notified about that change, and then Angular identifies all the places where that value is being is used i.e. that signal is being used, and then its able to update these places.
 So, the idea behind Signals is that you dont just have some initial values in them, but you also can change those values

## Change value of signal:
You can change the value of signal by calling the set method on that Signal object.


## When you have a value stored in a signal, don't access it like this: {{ selectedUser.name }}
Instead, access it like {{ selectedUser().name }} - you have to call the Signal value as a function by adding parentheses
This then executes the signal's read method, and gives you the value that is currently stored in the signal

### Angular sets up a tracking mechanism that automatically makes sure that the UI is updated whenever the underlying value is changed.

This is different from the State Management Mechanism we had before without Signals, because there we were using the sub-package Zone.js, which creates a zone around your components, which is simply like an invisible group mechanism where it listens to all the events and could trigger the state changes, so the data changes that could affect the UI.
So, whenever a trigger occurs, example, click occurs, Angular goes ahead and checks all the components in that zone to find out whether some data changed that needs to be updated on UI.

				|---------------------------------------------------------------------------------------------|
				|																							  |
				|							 	         App Component 										  |
				|											  |												  |
				|							--------------------------------------------					  |
				|							|				  |						   |					  |
				|						Header				 User					Tasks Component			  |
				|										  Component						|					  |
				|																	Task Component			  |
				|																							  |
				|														 									  |
				|																							  |
				|		Consider this whole box as a "ZONE"													  |
				|---------------------------------------------------------------------------------------------|



This is the change detection without signals.
Advantage of Signals is that Angular can get rid of this Zone.js and this zone concept.

this concept allows Angular to update the UI in a more fine grained way where it doesnt have to check anyting for every possible event that could occut anywhere in the application.

## Signals were introduced in Angular 16


### Computing values while using signals:

This is when we aren't using signals:

get imagePath(){
    return 'assets/users/' + this.selectedUser.avatar; // adding "this" here as we want to access the property of the class from within that same class
  }

While working with signals, use the "computed" function, which takes a function as an argument, and it should return the computed value. Shown below:
  imagePath = computed(() => 'assets/users/' + this.selectedUser().avatar);

Why use this "computed" method?
By using it, angular automatically analyzes whether you are reading any signal value inside of the function you passed. In that case, angular sets up a subscription that signal that's being used there.
selectedUser is the signal in this case. And whenever that signal receives a new value, only then Angular will recompute the imagePath
So, it is a very efficient way of setting up a computed value because it will not be recomputed everytime anything changes in this component or the overall application, but instead it will be recomputed
when if one of the signals is used inside of it.

### You just now have to make sure that in the template, you also execute this computed property, because under the hood it also creates a signal, Just a signal that will automatically update whenver the signals it depends on
(like selectedUser in this case) changes.
## You can see by hovering over imagePath that it is also a signal. Since that the case, you have to execute it in your template like a function as shown below:
	<img 
            [src]="imagePath()" --------- as you can see on this line, imagePath is a signal, so execute it like a function
            [alt] = "selectedUser().name"
    />
